
dat_lcd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000424  00000498  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000424  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         00001b48  00000000  00000000  000004a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000f13  00000000  00000000  00001ff0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .comment      00000011  00000000  00000000  00002f03  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  40:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  48:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  4c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  68:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  6c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  70:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  74:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  78:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  7c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  80:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  84:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  88:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 e2       	ldi	r30, 0x24	; 36
  a0:	f4 e0       	ldi	r31, 0x04	; 4
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 31       	cpi	r26, 0x10	; 16
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>
  b2:	0e 94 09 02 	call	0x412	; 0x412 <main>
  b6:	0c 94 10 02 	jmp	0x420	; 0x420 <_exit>

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <datarw>:
}

void datarw(){
	//Set Enable bit high, wait, set enable bit low
	//writes out data on other bits.
    PORTA |= _BV(E);
  be:	12 9a       	sbi	0x02, 2	; 2
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  c0:	81 ee       	ldi	r24, 0xE1	; 225
  c2:	94 e0       	ldi	r25, 0x04	; 4
  c4:	01 97       	sbiw	r24, 0x01	; 1
  c6:	f1 f7       	brne	.-4      	; 0xc4 <datarw+0x6>
  c8:	00 c0       	rjmp	.+0      	; 0xca <datarw+0xc>
  ca:	00 00       	nop
	_delay_ms(5);
	PORTA &= ~_BV(E);
  cc:	12 98       	cbi	0x02, 2	; 2
  ce:	08 95       	ret

000000d0 <lcd_cursor>:
#include "display.h"

int lcd_cursor()
{
	//Power Port D as outputs.
	DDRA |= 0xFF;
  d0:	81 b1       	in	r24, 0x01	; 1
  d2:	8f ef       	ldi	r24, 0xFF	; 255
  d4:	81 b9       	out	0x01, r24	; 1
  d6:	87 e8       	ldi	r24, 0x87	; 135
  d8:	93 e1       	ldi	r25, 0x13	; 19
  da:	01 97       	sbiw	r24, 0x01	; 1
  dc:	f1 f7       	brne	.-4      	; 0xda <lcd_cursor+0xa>
  de:	00 c0       	rjmp	.+0      	; 0xe0 <lcd_cursor+0x10>
  e0:	00 00       	nop

	//Wait more than 15ms after Vcc = 4.5V
	_delay_ms(20);

	//Function Set Command: 8-Bit interface
    PORTA &= ~_BV(E);
  e2:	12 98       	cbi	0x02, 2	; 2
    PORTA &= ~_BV(RS);
  e4:	10 98       	cbi	0x02, 0	; 2
    PORTA &= ~_BV(RW);
  e6:	11 98       	cbi	0x02, 1	; 2
    PORTA &= ~_BV(DB7);
  e8:	16 98       	cbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
  ea:	15 98       	cbi	0x02, 5	; 2
    PORTA |= _BV(DB5);
  ec:	14 9a       	sbi	0x02, 4	; 2
    PORTA |= _BV(DB4);
  ee:	13 9a       	sbi	0x02, 3	; 2
    datarw();
  f0:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
  f4:	81 ee       	ldi	r24, 0xE1	; 225
  f6:	94 e0       	ldi	r25, 0x04	; 4
  f8:	01 97       	sbiw	r24, 0x01	; 1
  fa:	f1 f7       	brne	.-4      	; 0xf8 <lcd_cursor+0x28>
  fc:	00 c0       	rjmp	.+0      	; 0xfe <lcd_cursor+0x2e>
  fe:	00 00       	nop

	//Wait more than 4.1 ms
	_delay_ms(5);

	//Function Set Command: 8-Bit interface. Part 2
    datarw();
 100:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 104:	89 ef       	ldi	r24, 0xF9	; 249
 106:	90 e0       	ldi	r25, 0x00	; 0
 108:	01 97       	sbiw	r24, 0x01	; 1
 10a:	f1 f7       	brne	.-4      	; 0x108 <lcd_cursor+0x38>
 10c:	00 c0       	rjmp	.+0      	; 0x10e <lcd_cursor+0x3e>
 10e:	00 00       	nop
	
	//Wait more than 100 us.
	_delay_ms(1);
	
	//Function Set Command 8-Bit interface. Part 3
	datarw();
 110:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 114:	89 ef       	ldi	r24, 0xF9	; 249
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	01 97       	sbiw	r24, 0x01	; 1
 11a:	f1 f7       	brne	.-4      	; 0x118 <lcd_cursor+0x48>
 11c:	00 c0       	rjmp	.+0      	; 0x11e <lcd_cursor+0x4e>
 11e:	00 00       	nop
	_delay_ms(1);

	//Now that this command is written, BF (busy flag) can be checked.

	//Function Set: Sets interface to 4-bit.
	PORTA &= ~_BV(DB7);
 120:	16 98       	cbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
 122:	15 98       	cbi	0x02, 5	; 2
    PORTA |= _BV(DB5);
 124:	14 9a       	sbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);
 126:	13 98       	cbi	0x02, 3	; 2
    datarw();
 128:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 12c:	89 ef       	ldi	r24, 0xF9	; 249
 12e:	90 e0       	ldi	r25, 0x00	; 0
 130:	01 97       	sbiw	r24, 0x01	; 1
 132:	f1 f7       	brne	.-4      	; 0x130 <lcd_cursor+0x60>
 134:	00 c0       	rjmp	.+0      	; 0x136 <lcd_cursor+0x66>
 136:	00 00       	nop
    _delay_ms(1);

	//Need to change how we send data at this point to accomodate 4-bit mode.

    //Function Set: Interface
    PORTA &= ~_BV(DB7);
 138:	16 98       	cbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
 13a:	15 98       	cbi	0x02, 5	; 2
    PORTA |= _BV(DB5);
 13c:	14 9a       	sbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);
 13e:	13 98       	cbi	0x02, 3	; 2
    datarw();
 140:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 144:	89 ef       	ldi	r24, 0xF9	; 249
 146:	90 e0       	ldi	r25, 0x00	; 0
 148:	01 97       	sbiw	r24, 0x01	; 1
 14a:	f1 f7       	brne	.-4      	; 0x148 <lcd_cursor+0x78>
 14c:	00 c0       	rjmp	.+0      	; 0x14e <lcd_cursor+0x7e>
 14e:	00 00       	nop
    _delay_ms(1);


    PORTA |= _BV(DB7); //diff
 150:	16 9a       	sbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
 152:	15 98       	cbi	0x02, 5	; 2
    PORTA &= ~_BV(DB5);
 154:	14 98       	cbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);
 156:	13 98       	cbi	0x02, 3	; 2
    datarw();
 158:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 15c:	89 ef       	ldi	r24, 0xF9	; 249
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	01 97       	sbiw	r24, 0x01	; 1
 162:	f1 f7       	brne	.-4      	; 0x160 <lcd_cursor+0x90>
 164:	00 c0       	rjmp	.+0      	; 0x166 <lcd_cursor+0x96>
 166:	00 00       	nop
    _delay_ms(1);

    //Display OFF
    PORTA &= ~_BV(DB7);
 168:	16 98       	cbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
 16a:	15 98       	cbi	0x02, 5	; 2
    PORTA &= ~_BV(DB5);
 16c:	14 98       	cbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);
 16e:	13 98       	cbi	0x02, 3	; 2
    datarw();
 170:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 174:	89 ef       	ldi	r24, 0xF9	; 249
 176:	90 e0       	ldi	r25, 0x00	; 0
 178:	01 97       	sbiw	r24, 0x01	; 1
 17a:	f1 f7       	brne	.-4      	; 0x178 <lcd_cursor+0xa8>
 17c:	00 c0       	rjmp	.+0      	; 0x17e <lcd_cursor+0xae>
 17e:	00 00       	nop
    _delay_ms(1);

    PORTA |= _BV(DB7);
 180:	16 9a       	sbi	0x02, 6	; 2
    PORTA |= _BV(DB6);//diff
 182:	15 9a       	sbi	0x02, 5	; 2
    PORTA |= _BV(DB5); //diff
 184:	14 9a       	sbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);
 186:	13 98       	cbi	0x02, 3	; 2
    datarw();
 188:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 18c:	89 ef       	ldi	r24, 0xF9	; 249
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	01 97       	sbiw	r24, 0x01	; 1
 192:	f1 f7       	brne	.-4      	; 0x190 <lcd_cursor+0xc0>
 194:	00 c0       	rjmp	.+0      	; 0x196 <lcd_cursor+0xc6>
 196:	00 00       	nop
    _delay_ms(1);

    //Clear Display
    PORTA &= ~_BV(DB7);
 198:	16 98       	cbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
 19a:	15 98       	cbi	0x02, 5	; 2
    PORTA &= ~_BV(DB5);
 19c:	14 98       	cbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);
 19e:	13 98       	cbi	0x02, 3	; 2
    datarw();
 1a0:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 1a4:	89 ef       	ldi	r24, 0xF9	; 249
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	01 97       	sbiw	r24, 0x01	; 1
 1aa:	f1 f7       	brne	.-4      	; 0x1a8 <lcd_cursor+0xd8>
 1ac:	00 c0       	rjmp	.+0      	; 0x1ae <lcd_cursor+0xde>
 1ae:	00 00       	nop
    _delay_ms(1);
    
    PORTA &= ~_BV(DB7);
 1b0:	16 98       	cbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
 1b2:	15 98       	cbi	0x02, 5	; 2
    PORTA &= ~_BV(DB5);
 1b4:	14 98       	cbi	0x02, 4	; 2
    PORTA |= _BV(DB4);
 1b6:	13 9a       	sbi	0x02, 3	; 2
    datarw();
 1b8:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 1bc:	89 ef       	ldi	r24, 0xF9	; 249
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	01 97       	sbiw	r24, 0x01	; 1
 1c2:	f1 f7       	brne	.-4      	; 0x1c0 <lcd_cursor+0xf0>
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <lcd_cursor+0xf6>
 1c6:	00 00       	nop
    _delay_ms(1);
	
    //Entry Mode Set
    PORTA &= ~_BV(DB7);
 1c8:	16 98       	cbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
 1ca:	15 98       	cbi	0x02, 5	; 2
    PORTA &= ~_BV(DB5);
 1cc:	14 98       	cbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);
 1ce:	13 98       	cbi	0x02, 3	; 2
    datarw();
 1d0:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 1d4:	89 ef       	ldi	r24, 0xF9	; 249
 1d6:	90 e0       	ldi	r25, 0x00	; 0
 1d8:	01 97       	sbiw	r24, 0x01	; 1
 1da:	f1 f7       	brne	.-4      	; 0x1d8 <lcd_cursor+0x108>
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <lcd_cursor+0x10e>
 1de:	00 00       	nop
    _delay_ms(1);

    PORTA &= ~_BV(DB7);
 1e0:	16 98       	cbi	0x02, 6	; 2
    PORTA |= _BV(DB6);
 1e2:	15 9a       	sbi	0x02, 5	; 2
    PORTA |= _BV(DB5);
 1e4:	14 9a       	sbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);//diff
 1e6:	13 98       	cbi	0x02, 3	; 2
    datarw();
 1e8:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 1ec:	89 ef       	ldi	r24, 0xF9	; 249
 1ee:	90 e0       	ldi	r25, 0x00	; 0
 1f0:	01 97       	sbiw	r24, 0x01	; 1
 1f2:	f1 f7       	brne	.-4      	; 0x1f0 <lcd_cursor+0x120>
 1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <lcd_cursor+0x126>
 1f6:	00 00       	nop
    _delay_ms(1);

    //Display On. Cursor and Blink on.
    PORTA &= ~_BV(DB7);
 1f8:	16 98       	cbi	0x02, 6	; 2
    PORTA &= ~_BV(DB6);
 1fa:	15 98       	cbi	0x02, 5	; 2
    PORTA &= ~_BV(DB5);
 1fc:	14 98       	cbi	0x02, 4	; 2
    PORTA &= ~_BV(DB4);
 1fe:	13 98       	cbi	0x02, 3	; 2
    datarw();
 200:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 204:	89 ef       	ldi	r24, 0xF9	; 249
 206:	90 e0       	ldi	r25, 0x00	; 0
 208:	01 97       	sbiw	r24, 0x01	; 1
 20a:	f1 f7       	brne	.-4      	; 0x208 <lcd_cursor+0x138>
 20c:	00 c0       	rjmp	.+0      	; 0x20e <lcd_cursor+0x13e>
 20e:	00 00       	nop
    _delay_ms(1);

    PORTA |= _BV(DB7);
 210:	16 9a       	sbi	0x02, 6	; 2
    PORTA |= _BV(DB6);
 212:	15 9a       	sbi	0x02, 5	; 2
    PORTA |= _BV(DB5);
 214:	14 9a       	sbi	0x02, 4	; 2
    PORTA |= _BV(DB4);
 216:	13 9a       	sbi	0x02, 3	; 2
    datarw();
 218:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 21c:	89 ef       	ldi	r24, 0xF9	; 249
 21e:	90 e0       	ldi	r25, 0x00	; 0
 220:	01 97       	sbiw	r24, 0x01	; 1
 222:	f1 f7       	brne	.-4      	; 0x220 <lcd_cursor+0x150>
 224:	00 c0       	rjmp	.+0      	; 0x226 <lcd_cursor+0x156>
 226:	00 00       	nop
    _delay_ms(1);

	return 0;
}
 228:	80 e0       	ldi	r24, 0x00	; 0
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	08 95       	ret

0000022e <letterwrite>:

void letterwrite(int a, int b, int c, int d){
	
	if(a==1) PORTA |= _BV(DB7);
 22e:	01 97       	sbiw	r24, 0x01	; 1
 230:	11 f4       	brne	.+4      	; 0x236 <letterwrite+0x8>
 232:	16 9a       	sbi	0x02, 6	; 2
 234:	01 c0       	rjmp	.+2      	; 0x238 <letterwrite+0xa>
	else   PORTA &= ~_BV(DB7);
 236:	16 98       	cbi	0x02, 6	; 2

	if (b==1) PORTA |= _BV(DB6);
 238:	61 30       	cpi	r22, 0x01	; 1
 23a:	71 05       	cpc	r23, r1
 23c:	11 f4       	brne	.+4      	; 0x242 <letterwrite+0x14>
 23e:	15 9a       	sbi	0x02, 5	; 2
 240:	01 c0       	rjmp	.+2      	; 0x244 <letterwrite+0x16>
	else PORTA &= ~_BV(DB6);
 242:	15 98       	cbi	0x02, 5	; 2
    
    	if(c==1) PORTA |= _BV(DB5);
 244:	41 30       	cpi	r20, 0x01	; 1
 246:	51 05       	cpc	r21, r1
 248:	11 f4       	brne	.+4      	; 0x24e <letterwrite+0x20>
 24a:	14 9a       	sbi	0x02, 4	; 2
 24c:	01 c0       	rjmp	.+2      	; 0x250 <letterwrite+0x22>
	else PORTA &= ~_BV(DB5);
 24e:	14 98       	cbi	0x02, 4	; 2
	
	if (d==1) PORTA |= _BV(DB4);
 250:	21 30       	cpi	r18, 0x01	; 1
 252:	31 05       	cpc	r19, r1
 254:	11 f4       	brne	.+4      	; 0x25a <letterwrite+0x2c>
 256:	13 9a       	sbi	0x02, 3	; 2
 258:	01 c0       	rjmp	.+2      	; 0x25c <letterwrite+0x2e>
    	else PORTA &= ~_BV(DB4);
 25a:	13 98       	cbi	0x02, 3	; 2
   	datarw();
 25c:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
 260:	89 ef       	ldi	r24, 0xF9	; 249
 262:	90 e0       	ldi	r25, 0x00	; 0
 264:	01 97       	sbiw	r24, 0x01	; 1
 266:	f1 f7       	brne	.-4      	; 0x264 <letterwrite+0x36>
 268:	00 c0       	rjmp	.+0      	; 0x26a <letterwrite+0x3c>
 26a:	00 00       	nop
 26c:	08 95       	ret

0000026e <instruction_read>:
    address = instruction_read()&0x7F;
    return address;
}

int instruction_read() 
{
 26e:	1f 93       	push	r17
 270:	cf 93       	push	r28
 272:	df 93       	push	r29
    int busy = 0, address = 0;
    uint8_t value;
    // Set LCD pins DB4-7 to be inputs with pull-ups
    DDRA &=~ (_BV(DB7)|_BV(DB6)|_BV(DB5)|_BV(DB4));    //Set pins as inputs;
 274:	81 b1       	in	r24, 0x01	; 1
 276:	87 78       	andi	r24, 0x87	; 135
 278:	81 b9       	out	0x01, r24	; 1

    // PORTA LCD pins RS to 0 and RW to 1
    PORTA &=~ _BV(RS);
 27a:	10 98       	cbi	0x02, 0	; 2
    PORTA |= _BV(RW);
 27c:	11 9a       	sbi	0x02, 1	; 2

    // load first 4 bits of read data into DB4-7
    // set the clock high and wait
    PORTA |= _BV(E);
 27e:	12 9a       	sbi	0x02, 2	; 2
 280:	81 ee       	ldi	r24, 0xE1	; 225
 282:	94 e0       	ldi	r25, 0x04	; 4
 284:	01 97       	sbiw	r24, 0x01	; 1
 286:	f1 f7       	brne	.-4      	; 0x284 <instruction_read+0x16>
 288:	00 c0       	rjmp	.+0      	; 0x28a <instruction_read+0x1c>
 28a:	00 00       	nop
    _delay_ms(5);

    // first bit is busy flag, last 3 are most significant 3 (of 7) bits of address counter
    // read data from the gpio pins
    value = PORTA & _BV(DB7); //this or PIND
 28c:	12 b1       	in	r17, 0x02	; 2
    if (value) busy = 1;
    value = PORTA & _BV(DB6);
 28e:	82 b1       	in	r24, 0x02	; 2
    address |= value<<6;
    value = PORTA & _BV(DB5);
 290:	c2 b1       	in	r28, 0x02	; 2
    address |= value<<5;
    value = PORTA & _BV(DB4);
 292:	a2 b1       	in	r26, 0x02	; 2
    address |= value<<4;
    
    // set the clock back to low
    PORTA &=~ _BV(E);
 294:	12 98       	cbi	0x02, 2	; 2
 296:	e9 ef       	ldi	r30, 0xF9	; 249
 298:	f0 e0       	ldi	r31, 0x00	; 0
 29a:	31 97       	sbiw	r30, 0x01	; 1
 29c:	f1 f7       	brne	.-4      	; 0x29a <instruction_read+0x2c>
 29e:	00 c0       	rjmp	.+0      	; 0x2a0 <instruction_read+0x32>
 2a0:	00 00       	nop
    _delay_ms(1);

    // load last 4 bits of read data into DB4-7
    // set the clock high and wait
    PORTA |= _BV(E);
 2a2:	12 9a       	sbi	0x02, 2	; 2
 2a4:	e1 ee       	ldi	r30, 0xE1	; 225
 2a6:	f4 e0       	ldi	r31, 0x04	; 4
 2a8:	31 97       	sbiw	r30, 0x01	; 1
 2aa:	f1 f7       	brne	.-4      	; 0x2a8 <instruction_read+0x3a>
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <instruction_read+0x40>
 2ae:	00 00       	nop
    _delay_ms(5);

    // read data from the GPIO pins
    value = PORTA & _BV(DB7); //this or PIND
 2b0:	e2 b1       	in	r30, 0x02	; 2
    address |= value<<3;
    value = PORTA & _BV(DB6);
 2b2:	62 b1       	in	r22, 0x02	; 2
    address |= value<<2;
    value = PORTA & _BV(DB5);
 2b4:	42 b1       	in	r20, 0x02	; 2
    address |= value<<1;
    value = PORTA & _BV(DB4);
 2b6:	52 b1       	in	r21, 0x02	; 2

    // first bit is busy flag, last 3 are most significant 3 (of 7) bits of address counter
    // read data from the gpio pins
    value = PORTA & _BV(DB7); //this or PIND
    if (value) busy = 1;
    value = PORTA & _BV(DB6);
 2b8:	80 72       	andi	r24, 0x20	; 32
    address |= value<<6;
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	26 e0       	ldi	r18, 0x06	; 6
 2be:	88 0f       	add	r24, r24
 2c0:	99 1f       	adc	r25, r25
 2c2:	2a 95       	dec	r18
 2c4:	e1 f7       	brne	.-8      	; 0x2be <instruction_read+0x50>
    value = PORTA & _BV(DB5);
 2c6:	c0 71       	andi	r28, 0x10	; 16
    address |= value<<5;
 2c8:	d0 e0       	ldi	r29, 0x00	; 0
 2ca:	35 e0       	ldi	r19, 0x05	; 5
 2cc:	cc 0f       	add	r28, r28
 2ce:	dd 1f       	adc	r29, r29
 2d0:	3a 95       	dec	r19
 2d2:	e1 f7       	brne	.-8      	; 0x2cc <instruction_read+0x5e>
 2d4:	8c 2b       	or	r24, r28
 2d6:	9d 2b       	or	r25, r29
    address |= value<<3;
    value = PORTA & _BV(DB6);
    address |= value<<2;
    value = PORTA & _BV(DB5);
    address |= value<<1;
    value = PORTA & _BV(DB4);
 2d8:	58 70       	andi	r21, 0x08	; 8
    value = PORTA & _BV(DB6);
    address |= value<<6;
    value = PORTA & _BV(DB5);
    address |= value<<5;
    value = PORTA & _BV(DB4);
    address |= value<<4;
 2da:	85 2b       	or	r24, r21
    if (value) busy = 1;
    value = PORTA & _BV(DB6);
    address |= value<<6;
    value = PORTA & _BV(DB5);
    address |= value<<5;
    value = PORTA & _BV(DB4);
 2dc:	a8 70       	andi	r26, 0x08	; 8
    address |= value<<4;
 2de:	b0 e0       	ldi	r27, 0x00	; 0
 2e0:	54 e0       	ldi	r21, 0x04	; 4
 2e2:	aa 0f       	add	r26, r26
 2e4:	bb 1f       	adc	r27, r27
 2e6:	5a 95       	dec	r21
 2e8:	e1 f7       	brne	.-8      	; 0x2e2 <instruction_read+0x74>
    PORTA |= _BV(E);
    _delay_ms(5);

    // read data from the GPIO pins
    value = PORTA & _BV(DB7); //this or PIND
    address |= value<<3;
 2ea:	8a 2b       	or	r24, r26
 2ec:	9b 2b       	or	r25, r27
    // set the clock high and wait
    PORTA |= _BV(E);
    _delay_ms(5);

    // read data from the GPIO pins
    value = PORTA & _BV(DB7); //this or PIND
 2ee:	e0 74       	andi	r30, 0x40	; 64
    address |= value<<3;
 2f0:	f0 e0       	ldi	r31, 0x00	; 0
 2f2:	73 e0       	ldi	r23, 0x03	; 3
 2f4:	ee 0f       	add	r30, r30
 2f6:	ff 1f       	adc	r31, r31
 2f8:	7a 95       	dec	r23
 2fa:	e1 f7       	brne	.-8      	; 0x2f4 <instruction_read+0x86>
    value = PORTA & _BV(DB6);
    address |= value<<2;
 2fc:	8e 2b       	or	r24, r30
 2fe:	9f 2b       	or	r25, r31
    _delay_ms(5);

    // read data from the GPIO pins
    value = PORTA & _BV(DB7); //this or PIND
    address |= value<<3;
    value = PORTA & _BV(DB6);
 300:	60 72       	andi	r22, 0x20	; 32
    address |= value<<2;
 302:	70 e0       	ldi	r23, 0x00	; 0
 304:	66 0f       	add	r22, r22
 306:	77 1f       	adc	r23, r23
 308:	66 0f       	add	r22, r22
 30a:	77 1f       	adc	r23, r23
    value = PORTA & _BV(DB5);
    address |= value<<1;
 30c:	86 2b       	or	r24, r22
 30e:	97 2b       	or	r25, r23
    value = PORTA & _BV(DB4);
    address |= value<<0;

    // set the clock back to low
    PORTA &=~ _BV(E);
 310:	12 98       	cbi	0x02, 2	; 2

    // Operation complete. Set DB4-7 pins back to outputs
    DDRA |= (_BV(DB7)|_BV(DB6)|_BV(DB5)|_BV(DB4)); 
 312:	51 b1       	in	r21, 0x01	; 1
 314:	58 67       	ori	r21, 0x78	; 120
 316:	51 b9       	out	0x01, r21	; 1

    // Write LCD pins RS back to 0 and RW back to 0
    PORTA &=~ _BV(RS);
 318:	10 98       	cbi	0x02, 0	; 2
    PORTA &=~ _BV(RW);
 31a:	11 98       	cbi	0x02, 1	; 2
    // read data from the GPIO pins
    value = PORTA & _BV(DB7); //this or PIND
    address |= value<<3;
    value = PORTA & _BV(DB6);
    address |= value<<2;
    value = PORTA & _BV(DB5);
 31c:	40 71       	andi	r20, 0x10	; 16
    address |= value<<1;
 31e:	50 e0       	ldi	r21, 0x00	; 0
 320:	44 0f       	add	r20, r20
 322:	55 1f       	adc	r21, r21
    value = PORTA & _BV(DB4);
    address |= value<<0;
 324:	84 2b       	or	r24, r20
 326:	95 2b       	or	r25, r21
    _delay_ms(5);

    // first bit is busy flag, last 3 are most significant 3 (of 7) bits of address counter
    // read data from the gpio pins
    value = PORTA & _BV(DB7); //this or PIND
    if (value) busy = 1;
 328:	16 fb       	bst	r17, 6
 32a:	22 27       	eor	r18, r18
 32c:	20 f9       	bld	r18, 0
 32e:	30 e0       	ldi	r19, 0x00	; 0
    // Write LCD pins RS back to 0 and RW back to 0
    PORTA &=~ _BV(RS);
    PORTA &=~ _BV(RW);

    // Return the address and whether or not the device is busy
    return (address | busy<<7);
 330:	36 95       	lsr	r19
 332:	32 2f       	mov	r19, r18
 334:	22 27       	eor	r18, r18
 336:	37 95       	ror	r19
 338:	27 95       	ror	r18
}
 33a:	82 2b       	or	r24, r18
 33c:	93 2b       	or	r25, r19
 33e:	df 91       	pop	r29
 340:	cf 91       	pop	r28
 342:	1f 91       	pop	r17
 344:	08 95       	ret

00000346 <get_current_address>:
    }
}

int get_current_address() {
    int address;
    address = instruction_read()&0x7F;
 346:	0e 94 37 01 	call	0x26e	; 0x26e <instruction_read>
    return address;
}
 34a:	8f 77       	andi	r24, 0x7F	; 127
 34c:	99 27       	eor	r25, r25
 34e:	08 95       	ret

00000350 <write_db74>:
    datarw();
}

void write_db74(int DB7_val, int DB6_val, int DB5_val, int DB4_val)
{
    if (DB7_val == 0) PORTA &=~ _BV(DB7);
 350:	89 2b       	or	r24, r25
 352:	11 f4       	brne	.+4      	; 0x358 <write_db74+0x8>
 354:	16 98       	cbi	0x02, 6	; 2
 356:	01 c0       	rjmp	.+2      	; 0x35a <write_db74+0xa>
    else PORTA |= _BV(DB7);
 358:	16 9a       	sbi	0x02, 6	; 2
    if (DB6_val == 0) PORTA &=~ _BV(DB6);
 35a:	67 2b       	or	r22, r23
 35c:	11 f4       	brne	.+4      	; 0x362 <write_db74+0x12>
 35e:	15 98       	cbi	0x02, 5	; 2
 360:	01 c0       	rjmp	.+2      	; 0x364 <write_db74+0x14>
    else PORTA |= _BV(DB6);
 362:	15 9a       	sbi	0x02, 5	; 2
    if (DB5_val == 0) PORTA &=~ _BV(DB5);
 364:	45 2b       	or	r20, r21
 366:	11 f4       	brne	.+4      	; 0x36c <write_db74+0x1c>
 368:	14 98       	cbi	0x02, 4	; 2
 36a:	01 c0       	rjmp	.+2      	; 0x36e <write_db74+0x1e>
    else PORTA |= _BV(DB5);
 36c:	14 9a       	sbi	0x02, 4	; 2
    if (DB4_val == 0) PORTA &=~ _BV(DB4);
 36e:	23 2b       	or	r18, r19
 370:	11 f4       	brne	.+4      	; 0x376 <write_db74+0x26>
 372:	13 98       	cbi	0x02, 3	; 2
 374:	08 95       	ret
    else PORTA |= _BV(DB4);
 376:	13 9a       	sbi	0x02, 3	; 2
 378:	08 95       	ret

0000037a <data_write>:
{
    data_write((uint8_t)mychar);
}

void data_write(uint8_t val)
{
 37a:	cf 93       	push	r28
 37c:	c8 2f       	mov	r28, r24

    //write data to DD RAM
    PORTA |= _BV(RS);
 37e:	10 9a       	sbi	0x02, 0	; 2
    PORTA &=~ _BV(RW);
 380:	11 98       	cbi	0x02, 1	; 2
    write_db74((val>>7)&1,(val>>6)&1,(val>>5)&1,(val>>4)&1);
 382:	84 fb       	bst	r24, 4
 384:	22 27       	eor	r18, r18
 386:	20 f9       	bld	r18, 0
 388:	85 fb       	bst	r24, 5
 38a:	44 27       	eor	r20, r20
 38c:	40 f9       	bld	r20, 0
 38e:	86 fb       	bst	r24, 6
 390:	66 27       	eor	r22, r22
 392:	60 f9       	bld	r22, 0
 394:	88 1f       	adc	r24, r24
 396:	88 27       	eor	r24, r24
 398:	88 1f       	adc	r24, r24
 39a:	30 e0       	ldi	r19, 0x00	; 0
 39c:	50 e0       	ldi	r21, 0x00	; 0
 39e:	70 e0       	ldi	r23, 0x00	; 0
 3a0:	90 e0       	ldi	r25, 0x00	; 0
 3a2:	0e 94 a8 01 	call	0x350	; 0x350 <write_db74>
    datarw();
 3a6:	0e 94 5f 00 	call	0xbe	; 0xbe <datarw>
    write_db74((val>>3)&1,(val>>2)&1,(val>>1)&1,(val>>0)&1);
 3aa:	2c 2f       	mov	r18, r28
 3ac:	21 70       	andi	r18, 0x01	; 1
 3ae:	c1 fb       	bst	r28, 1
 3b0:	44 27       	eor	r20, r20
 3b2:	40 f9       	bld	r20, 0
 3b4:	c2 fb       	bst	r28, 2
 3b6:	66 27       	eor	r22, r22
 3b8:	60 f9       	bld	r22, 0
 3ba:	30 e0       	ldi	r19, 0x00	; 0
 3bc:	50 e0       	ldi	r21, 0x00	; 0
 3be:	70 e0       	ldi	r23, 0x00	; 0
 3c0:	c3 fb       	bst	r28, 3
 3c2:	88 27       	eor	r24, r24
 3c4:	80 f9       	bld	r24, 0
 3c6:	90 e0       	ldi	r25, 0x00	; 0
 3c8:	0e 94 a8 01 	call	0x350	; 0x350 <write_db74>
    datarw();
}
 3cc:	cf 91       	pop	r28
    PORTA |= _BV(RS);
    PORTA &=~ _BV(RW);
    write_db74((val>>7)&1,(val>>6)&1,(val>>5)&1,(val>>4)&1);
    datarw();
    write_db74((val>>3)&1,(val>>2)&1,(val>>1)&1,(val>>0)&1);
    datarw();
 3ce:	0c 94 5f 00 	jmp	0xbe	; 0xbe <datarw>

000003d2 <char_write>:
    return (address | busy<<7);
}

void char_write(char mychar)
{
    data_write((uint8_t)mychar);
 3d2:	0c 94 bd 01 	jmp	0x37a	; 0x37a <data_write>

000003d6 <string_write>:
 3d6:	0f 93       	push	r16
 3d8:	1f 93       	push	r17
 3da:	cf 93       	push	r28
 3dc:	df 93       	push	r29
 3de:	ec 01       	movw	r28, r24
 3e0:	8c 01       	movw	r16, r24
 3e2:	fe 01       	movw	r30, r28
 3e4:	01 90       	ld	r0, Z+
 3e6:	00 20       	and	r0, r0
 3e8:	e9 f7       	brne	.-6      	; 0x3e4 <string_write+0xe>
 3ea:	31 97       	sbiw	r30, 0x01	; 1
 3ec:	ec 1b       	sub	r30, r28
 3ee:	fd 0b       	sbc	r31, r29
 3f0:	c8 01       	movw	r24, r16
 3f2:	8c 1b       	sub	r24, r28
 3f4:	9d 0b       	sbc	r25, r29
 3f6:	8e 17       	cp	r24, r30
 3f8:	9f 07       	cpc	r25, r31
 3fa:	30 f4       	brcc	.+12     	; 0x408 <string_write+0x32>
 3fc:	f8 01       	movw	r30, r16
 3fe:	81 91       	ld	r24, Z+
 400:	8f 01       	movw	r16, r30
 402:	0e 94 bd 01 	call	0x37a	; 0x37a <data_write>
 406:	ed cf       	rjmp	.-38     	; 0x3e2 <string_write+0xc>
 408:	df 91       	pop	r29
 40a:	cf 91       	pop	r28
 40c:	1f 91       	pop	r17
 40e:	0f 91       	pop	r16
 410:	08 95       	ret

00000412 <main>:


int main (int argc, char *argv[])
{
	//Intitialize LCD. Set Blinking cursor.
	lcd_cursor();
 412:	0e 94 68 00 	call	0xd0	; 0xd0 <lcd_cursor>

    
	//Write ECE to screen
    string_write("Library Victory");
 416:	80 e0       	ldi	r24, 0x00	; 0
 418:	91 e0       	ldi	r25, 0x01	; 1
 41a:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <string_write>
 41e:	ff cf       	rjmp	.-2      	; 0x41e <main+0xc>

00000420 <_exit>:
 420:	f8 94       	cli

00000422 <__stop_program>:
 422:	ff cf       	rjmp	.-2      	; 0x422 <__stop_program>
